#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/platform_device.h>      /* For platform devices */
#include <linux/interrupt.h>            /* For IRQ */
#include <linux/gpio.h>                 /* For Legacy integer based GPIO */
#include <linux/of_gpio.h>              /* For of_gpio* functions */
#include <linux/of.h>                   /* For DT*/
#include <linux/delay.h>                   /* For DT*/


#include <linux/err.h>
#include <linux/of_device.h>
#include <linux/pinctrl/pinctrl.h>
#include <linux/pinctrl/pinmux.h>
#include <linux/pinctrl/consumer.h>
#include <linux/atomic.h>
#include <linux/clk.h>
#include <linux/interrupt.h>
#include <linux/math64.h>
#include <linux/atomic.h>
#include <linux/idr.h>
#include <linux/ioctl.h>
#include <linux/uuid.h>
#include <linux/miscdevice.h>

#define DEFAULT_PWR_ON       1
#define DEFAULT_WIRELESS_DIS 0
#define DEFAULT_MODULE_RESET 0
#define DEFAULT_GPS_DIS      1
#define DEFAULT_MUX_USB      0
#define DEFAULT_SDIO_RESET   0
#define DEFAULT_SDIO_WAKEUP  0
#define DEFAULT_WIFI_DISABLE1  1
#define DEFAULT_WIFI_DISABLE2  0

#define GSM_STATE_ON         0
#define GSM_STATE_OFF        1
#define GPIO_PIN_NUMBER(group, pin) (pin + (group-1)*32) 
//GSM WIRELESS DISABLE
#define PIN_GSM_WIRELESS_DISABLE GPIO_PIN_NUMBER(6,4)
#define PIN_MUX_USB_CMD          GPIO_PIN_NUMBER(1,25)

#define GSM_ACTIVATE    _IOW('a', 'a', int32_t*)
#define GSM_DEACTIVATE  _IOW('b', 'b', int32_t*)
#define MUX_USB_CMD_ZERO     _IOW('c', 'c', int32_t*)
#define MUX_USB_CMD_ONE     _IOW('d', 'd', int32_t*)

typedef struct gpio_gsm{
   unsigned int rst_pin;
   unsigned int wdis_pin;
   unsigned int gpsdis_pin;
   unsigned int muxusb_pin;
   unsigned int pwron_pin;
   unsigned int sdio_reset_pin;
   unsigned int sdio_wakeup_pin;
   unsigned int wifi_disable1_pin;
   unsigned int wifi_disable2_pin;
}gpio_gsm_t;
gpio_gsm_t ctx_gpio_gsm;
struct pinctrl *p;
struct pinctrl_state *sdefault;

static long int gsm_pdrv_ioctl(struct file *f, unsigned int cmd, long unsigned int arg);
static const struct file_operations gsm_fops = {
 .owner    = THIS_MODULE,
 .unlocked_ioctl = gsm_pdrv_ioctl,
   .llseek   = noop_llseek,
  };

static struct miscdevice gsm_dev = {
 .minor=MISC_DYNAMIC_MINOR,
 .name = "gsm_update",
 .nodename = "gsmupdate",
 .fops = &gsm_fops
};
/*
 *  * Let us consider the node bellow
 *   *
 *            */
static const struct of_device_id gpio_dt_ids[] = {
     { .compatible = "safran,gsm", },
     { /* sentinel */ }
};
static int gsm_pinmux_helper_probe(struct platform_device *pdev)
{
    struct pinctrl *pinctrl;
    pinctrl = devm_pinctrl_get_select_default(&pdev->dev);

    /* don't bother with anything */
   return PTR_RET(pinctrl);
}
static int gsm_pdrv_probe (struct platform_device *pdev)
{
      int ret;
      struct device_node *node = pdev->dev.of_node;
      struct pinctrl *pinctrl;

      if (!node)
          return -ENOENT; 
      printk("!!!!!!!!!!!GSM");
      pinctrl = gsm_pinmux_helper_probe(pdev);
      if (IS_ERR(pinctrl)) {
      /* special handling for probe defer */
         if (PTR_ERR(pinctrl) == -EPROBE_DEFER)
           return -EPROBE_DEFER;
   
          dev_warn(&pdev->dev,
              "pins are not configured from the driver\n");
      }
      p = devm_pinctrl_get(&pdev->dev);
      if (IS_ERR(p)) {
          /*  clean up  here */
          printk("!!!!!!!!!!!GSM ERR:No pinctrl found");
          return PTR_ERR(p);
      }

      sdefault = pinctrl_lookup_state(p, PINCTRL_STATE_DEFAULT);
      if (IS_ERR(sdefault)) {
          /* clean up  here */
          printk("!!!!!!!!!!!GSM ERR:Default state not found");
          return PTR_ERR(sdefault);
      }

      ret = pinctrl_select_state(p,sdefault);
     if (ret < 0) {
                /* clean up  here */
          printk("!!!!!!!!!!!GSM ERR: Impossible to select pin mux");
          return ret;
     }
     printk("!!!!!!!!!!!!!!!!!!!!! GSM DTS parsing");
    /********************
    GSM_MODULE_RESET_N pin
    *****************/
    ctx_gpio_gsm.rst_pin =of_get_named_gpio(node, "rst-pin", 0);
    if (!gpio_is_valid(ctx_gpio_gsm.rst_pin))
    {
        dev_err(&pdev->dev, "No valid GSM: rst-pin\n");
        return -EINVAL;
    }
    gpio_set_value(ctx_gpio_gsm.rst_pin, DEFAULT_MODULE_RESET );
    ret = devm_gpio_request_one(&pdev->dev, ctx_gpio_gsm.rst_pin, GPIOF_DIR_OUT | GPIOF_INIT_HIGH, "RST PIN GSM");
    if (ret) {
      dev_err( &pdev->dev, "Could not initialize RST PIN GSM probe\n");
      return -ENOMEM;
    }
    printk("!!!!!!!!!!!!!!!!!!!!! GSM RST PIN RESET");
    /********************
    GSM_MODULE_PWR_ON pin
    *****************/
    ctx_gpio_gsm.pwron_pin =of_get_named_gpio(node, "pwron-pin", 0);
    if (!gpio_is_valid(ctx_gpio_gsm.pwron_pin))
    {
        dev_err(&pdev->dev, "No valid GSM pwron-pin\n");
        return -EINVAL;
    }
    gpio_set_value(ctx_gpio_gsm.pwron_pin, DEFAULT_PWR_ON );
    ret = devm_gpio_request_one(&pdev->dev, ctx_gpio_gsm.pwron_pin, GPIOF_DIR_OUT | GPIOF_INIT_HIGH, "PWR ON PIN GSM");
    if (ret) {
      dev_err( &pdev->dev, "Could not initialize GSM: PWR ON pin\n");
      return -ENOMEM;
    }
    printk("!!!!!!!!!!!!!!!!!!!!! GSM PWR ON PIN SET");
    /********************
    MUX_USB_CMD pin
    *****************/
    ctx_gpio_gsm.muxusb_pin =of_get_named_gpio(node, "muxusb-pin", 0);
    if (!gpio_is_valid(ctx_gpio_gsm.muxusb_pin))
    {
        dev_err(&pdev->dev, "No valid GSM muxusb-pin\n");
        return -EINVAL;
    }
    gpio_set_value(ctx_gpio_gsm.muxusb_pin, DEFAULT_MUX_USB );
    ret = devm_gpio_request_one(&pdev->dev, ctx_gpio_gsm.muxusb_pin, GPIOF_DIR_OUT | GPIOF_INIT_LOW, "MUX USB PIN GSM");
    if (ret) {
      dev_err(&pdev->dev, "Could not initialize GSM:MUX USB probe\n");
      return -ENOMEM;
    }
    printk("!!!!!!!!!!!!!!!!!!!!! GSM MUX USB PIN RESET");
    /********************
    MODULE_GPS_DISABLE_N pin
    *****************/
    ctx_gpio_gsm.gpsdis_pin =of_get_named_gpio(node, "gpsdis-pin", 0);
    if (!gpio_is_valid(ctx_gpio_gsm.gpsdis_pin))
    {
        dev_err(&pdev->dev, "No valid GSM gpsdis-pin\n");
        return -EINVAL;
    }
    gpio_set_value(ctx_gpio_gsm.gpsdis_pin, DEFAULT_GPS_DIS );
    ret = devm_gpio_request_one(&pdev->dev, ctx_gpio_gsm.gpsdis_pin, GPIOF_DIR_OUT | GPIOF_INIT_HIGH, "GPS DISABLE PIN GSM");
    if (ret) {
      dev_err(&pdev->dev, "Could not initialize GSM:GPS DISABLE probe\n");
      return -ENOMEM;
    }
    printk("!!!!!!!!!!!!!!!!!!!!! GSM GPS DISABLE PIN SET");
    /********************
    MODULE_WIRELESS_DISABLE_N pin
    *****************/
    ctx_gpio_gsm.wdis_pin =of_get_named_gpio(node, "wdis-pin", 0);
    if (!gpio_is_valid(ctx_gpio_gsm.wdis_pin))
    {
        dev_err(&pdev->dev, "No valid GSM WIRELESS wdis-pin\n");
        return -EINVAL;
    }
    gpio_set_value(ctx_gpio_gsm.wdis_pin, DEFAULT_WIRELESS_DIS );
    ret = devm_gpio_request_one(&pdev->dev, ctx_gpio_gsm.wdis_pin, GPIOF_DIR_OUT | GPIOF_INIT_HIGH, "WIRELESS DISABLE PIN GSM");
    if (ret) {
      dev_err(&pdev->dev, "Could not initialize GSM:WIRELESS DISABLE probe\n");
      return -ENOMEM;
    }
   // gpio_direction_ouput(ctx_gpio_gsm.wdis_pin,0);
    printk("!!!!!!!!!!!!!!!!!!!!! GSM WIRELESS DISABLE PIN RESET=%d",DEFAULT_WIRELESS_DIS);
//    /********************
//    SDIO_RESET pin
//    *****************/
//    ctx_gpio_gsm.sdio_reset_pin =of_get_named_gpio(node, "sdio_reset-pin", 0);
//    if (!gpio_is_valid(ctx_gpio_gsm.sdio_reset_pin))
//    {
//        dev_err(&pdev->dev, "No valid WIFI SDIO sdio_reset-pin\n");
//        return -EINVAL;
//    }
//    gpio_set_value(ctx_gpio_gsm.sdio_reset_pin, DEFAULT_SDIO_RESET );
//    ret = devm_gpio_request_one(&pdev->dev, ctx_gpio_gsm.sdio_reset_pin, GPIOF_DIR_OUT | GPIOF_INIT_LOW, "SDIO RESET PIN WIFI");
//    if (ret) {
//      dev_err(&pdev->dev, "Could not initialize WIFI:SDIO RESET probe\n");
//      return -ENOMEM;
//    }
//    /********************
//    SDIO_WAKEUP pin
//    *****************/
//    ctx_gpio_gsm.sdio_wakeup_pin =of_get_named_gpio(node, "sdio_wakeup-pin", 0);
//    if (!gpio_is_valid(ctx_gpio_gsm.sdio_wakeup_pin))
//    {
//        dev_err(&pdev->dev, "No valid WIFI SDIO sdio_wakeup-pin\n");
//        return -EINVAL;
//    }
//    gpio_set_value(ctx_gpio_gsm.sdio_wakeup_pin, DEFAULT_SDIO_WAKEUP );
//    ret = devm_gpio_request_one(&pdev->dev, ctx_gpio_gsm.sdio_wakeup_pin, GPIOF_DIR_OUT | GPIOF_INIT_LOW, "SDIO WAKE UP PIN WIFI");
//    if (ret) {
//      dev_err(&pdev->dev, "Could not initialize WIFI:SDIO WAKEUP probe\n");
//      return -ENOMEM;
//    }
//   // gpio_direction_ouput(ctx_gpio_gsm.wdis_pin,0);
//    printk("!!!!!!!!!!!!!!!!!!!! GSM pin configured successfully ");
//
//    /********************
//    WIFI_DISABLE1 pin
//    *****************/
//    ctx_gpio_gsm.wifi_disable1_pin =of_get_named_gpio(node, "wifi_disable1-pin", 0);
//    if (!gpio_is_valid(ctx_gpio_gsm.wifi_disable1_pin))
//    {
//        dev_err(&pdev->dev, "No valid WIFI wifi_disable1-pin\n");
//        return -EINVAL;
//    }
//    gpio_set_value(ctx_gpio_gsm.wifi_disable1_pin, DEFAULT_WIFI_DISABLE1 );
//    ret = devm_gpio_request_one(&pdev->dev, ctx_gpio_gsm.wifi_disable1_pin, GPIOF_DIR_OUT | GPIOF_INIT_HIGH, "WIFI DISABLE1 PIN WIFI");
//    if (ret) {
//      dev_err(&pdev->dev, "Could not initialize WIFI:DISABLE1 probe\n");
//      return -ENOMEM;
//    }
//    /********************
//    WIFI_DISABLE2 pin
//    *****************/
//    ctx_gpio_gsm.wifi_disable2_pin =of_get_named_gpio(node, "wifi_disable2-pin", 0);
//    if (!gpio_is_valid(ctx_gpio_gsm.wifi_disable2_pin))
//    {
//        dev_err(&pdev->dev, "No valid WIFI wifi_disable2-pin\n");
//        return -EINVAL;
//    }
//    gpio_set_value(ctx_gpio_gsm.wifi_disable2_pin, DEFAULT_WIFI_DISABLE2 );
//    ret = devm_gpio_request_one(&pdev->dev, ctx_gpio_gsm.wifi_disable2_pin, GPIOF_DIR_OUT | GPIOF_INIT_LOW, "WIFI DISABLE2 PIN WIFI");
//    if (ret) {
//      dev_err(&pdev->dev, "Could not initialize WIFI:DISABLE2 probe\n");
//      return -ENOMEM;
//    }
//    printk("!!!!!!!!!!!!!!!!!!!! WIFI pin configured successfully ");
    ret = misc_register(&gsm_dev);
    if (ret)
       goto out;
   
    return 0;
out:
    return 1;
}

static int gsm_pdrv_remove(struct platform_device *pdev)
{
   misc_deregister(&gsm_dev);
   dev_info(&pdev->dev, "Unregistered\n");
   return 0;
}
int pin_on(int pin) {
    int valid = gpio_is_valid(pin);
    if (valid) {
       printk(KERN_ALERT "Kernel=>GPIO %d is meant to be valid - configuring as output pin\n", pin);
       gpio_direction_output(pin, 0);
       gpio_set_value(pin, 1);
   }
   return valid;
}

int pin_off(int pin) {
    int valid = gpio_is_valid(pin);
    if (valid) {
        printk(KERN_ALERT "Kernel=>GPIO %d is meant to be valid - configuring as output pin\n", pin);
        gpio_direction_output(pin, 0);
        gpio_set_value(pin, 0);
    }
   return valid;
}
static ssize_t gpio_write_val(int value)
{
  if(value==1) 
  {
    printk("GSM PIN IS ON");
    pin_on(PIN_GSM_WIRELESS_DISABLE);
  }
  else
  {
    printk("GSM PIN IS OFF");
    pin_off(PIN_GSM_WIRELESS_DISABLE);
  }
  return(1);
}
static long int gsm_pdrv_ioctl(struct file *f, unsigned int cmd, long unsigned int arg)
{
   void __user *p;
   int ret = 0;
//   struct device_node *node = pdev->dev.of_node;
   p = (void __user *)arg;
   switch (cmd) {
     case GSM_ACTIVATE:
       printk(KERN_INFO "GSM ACTIVATE");
       gpio_write_val(GSM_STATE_ON);
       break;
      case GSM_DEACTIVATE:
       printk(KERN_INFO "GSM DEACTIVATE");
       gpio_write_val(GSM_STATE_OFF);
       break;
     case MUX_USB_CMD_ZERO:
       printk("MUX USB_CMD PIN IS OFF");    
       pin_off(PIN_MUX_USB_CMD);
       break;
     case MUX_USB_CMD_ONE:
       printk("MUX USB_CMD PIN IS ON");    
       pin_on(PIN_MUX_USB_CMD);
       break;
      default:
         ret = -ENOIOCTLCMD;
         break;
   }
  return 0;
}

static struct platform_driver gsmpdrv = {
      .probe    = gsm_pdrv_probe,
     .remove    = gsm_pdrv_remove,
     .driver     = {
          .name     = "gpio_legacy_sample",
          .of_match_table = of_match_ptr(gpio_dt_ids),  
          .owner    = THIS_MODULE,
          },
};
module_platform_driver(gsmpdrv);

MODULE_AUTHOR("Gilles Desjardin <gilles.desjardin");

