#!/bin/sh
#--------------------------------------------------------------------------------
# Script that handle Iridium 9602 communication
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# TODO:
#  * function to send binary
#  * function for BIT (see SIRD)
#--------------------------------------------------------------------------------
# Default configuration and tools
SER_PORT=/dev/ttySC0
SBD_MAX_SIZE=70

DATA_DIR="/containers/container-as/var/sat/fetch/transfers"
DATA_FILE="${DATA_DIR}/transfersat"
TRIGGER_LISTEN_DIR="/containers/container-as/var/services/sat/input"
TRIGGER_SEND_FILE=".trigger_send"
TRIGGER_ENABLE_FILE=".trigger_enable"
TRIGGER_DISABLE_FILE=".trigger_disable"

NOTIFY_HEAT_FOLDER="/containers/container-as/var/notification/to_HEATS"
NOTIFY_HEAT_SUCCESS_FILE="${NOTIFY_HEAT_FOLDER}/.success_SAT_SEND"
NOTIFY_HEAT_FAILURE_FILE="${NOTIFY_HEAT_FOLDER}/.fail_SAT_SEND"

#--------------------------------------------------------------------------------
# FUNCTIONS
#--------------------------------------------------------------------------------
send_cmd() {
    # start reading before sending the message
    (read -d"\r" -n $2 -t $3 resp < ${SER_PORT};echo -e ${resp}) &

    # make sure the command is started
    sleep 0.1

    # kick off the command
    echo -ne $1 > ${SER_PORT}

    # wait for read command to be terminated 
    wait
}

power_on() {
    # make sure the serial is properly configured
    stty -F /dev/ttySC0 19200 -parenb -parodd -cmspar cs8 hupcl -cstopb cread clocal    \
        -crtscts -ignbrk -brkint ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon \
        ixoff -iuclc ixany -imaxbel -iutf8 -opost -olcuc -ocrnl -onlcr -onocr -onlret   \
        -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig -icanon iexten -echo echoe echok    \
        -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc

    # export DTR pin if needed
    if [ ! -d /sys/class/gpio/gpio509 ]; then
        echo 509 > /sys/class/gpio/export
        echo out > /sys/class/gpio/gpio509/direction
    fi
    
    # prevent device from sending unattended messages
    echo 1 > /sys/class/gpio/gpio509/value

    # power on the device
    hv3gpio -s on

    # set DTR to available
    echo 0 > /sys/class/gpio/gpio509/value;

    # give some delay for device boot
    sleep 0.5

    # make sure device echo is disabled
    if [ -z "$(send_cmd "ATS14=168\r" 32 1 | grep "OK")" ]; then
        echo "Unable to disable echo from device"
        return
    fi
}

power_off() {
    # DTR as unavailable
    echo 1 > /sys/class/gpio/gpio509/value

    # power off the device
    hv3gpio -s off
}

poke_device() {
    # check if the serial port is already used
    serial_used=`fuser ${SER_PORT}`
    if [ -n  "${serial_used}" ]; then
        echo "Serial port ${SER_PORT} already in use"
        return 1
    fi

    # AT command must return 'OK'
    if [ -z "$(send_cmd "AT\r" 6 1 | grep "OK")" ]; then
        echo "Device does not answer"
        return 1
    fi

    return 0
}

send_message_success() {
        echo "Message successfully transfered"
        touch "${NOTIFY_HEAT_SUCCESS_FILE}"
}

send_message_failure() {
        echo $1
        touch "${NOTIFY_HEAT_FAILURE_FILE}"
}

send_txt_msg() {
    # check if the device is reachable
    if ! poke_device; then
        send_message_failure "Device unreachable"
        return
    fi

    # check that file exists
    if [ ! -e "${DATA_FILE}" ]; then
        send_message_failure "File not found: ${DATA_FILE}"
        return
    fi

    # check maximum message size
    if [ $(wc -c ${DATA_FILE}| awk '{print $1}') -gt ${SBD_MAX_SIZE} ]; then
        send_message_failure "File too big: max size ${SBD_MAX_SIZE}"
        return
    fi

    # check for network availability
    network_available=$(send_cmd "AT+CIER=1,0,1,0\r" 19 10 )
    if [ -z "$(echo ${network_available} | grep "OK")" ]; then
        send_message_failure "Unable to check network status"
        return
    fi

    network_available=$(echo ${network_available} | sed -r 's/.*CIEV:1,([0-9]).*/\1/')
    if [ "${network_available}" != "1" ]; then
        send_message_failure "Network unavailable"
        return
    fi

    # fill text buffer in order to send the message
    if [ -z "$(send_cmd "AT+SBDWT=$(cat ${DATA_FILE})\r" 6 1 | grep "OK")" ]; then
        send_message_failure "Unable to fill message buffer"
        return
    fi

    # kick off the message
    message_sent=$(send_cmd "AT+SBDIX\r"  39 60)
    if [ -z "$(echo ${message_sent} | grep "OK")" ]; then
        send_message_failure "Unable to kick off the message"
        return
    fi

    # check MO status
    message_sent=$(echo ${message_sent} | sed -r 's/.*SBDIX: ([0-9]*),.*/\1/')
    if [ ${message_sent} -gt 2 ]; then
        send_message_failure "Received error while sending the message"
        return
    fi

    send_message_success
}

listening() {
    # running inotify in monitor mode is a trick to avoid missing event while processing 
    inotifywait -e create ${TRIGGER_LISTEN_DIR} --format=%f -q -m | while read -r entry; do 
        # check requested actions
        case ${entry} in
            ${TRIGGER_ENABLE_FILE})
                echo "POWER ON THE DEVICE"
                rm "${TRIGGER_LISTEN_DIR}/${TRIGGER_ENABLE_FILE}"
                power_on
                ;;
            ${TRIGGER_SEND_FILE})
                echo "SEND TXT MESSAGE"
                rm "${TRIGGER_LISTEN_DIR}/${TRIGGER_SEND_FILE}"
                send_txt_msg
                ;;
            ${TRIGGER_DISABLE_FILE})
                echo "POWER OFF THE DEVICE"
                rm "${TRIGGER_LISTEN_DIR}/${TRIGGER_DISABLE_FILE}"
                power_off
                ;;
            *)
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# MAIN
#--------------------------------------------------------------------------------
if [ "$#" -gt "1" ]; then
    echo -e "[FATAL] Too many arguments. Exit..."
    exit 1
fi

case "$1" in
    "on")
        power_on
        ;;
    "poke")
        poke_device
        ;;
    "listening")
        listening
    "off"
        power_off
        ;;
esac

# let the function called returning its own value

