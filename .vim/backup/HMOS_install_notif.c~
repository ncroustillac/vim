/*
 =======================================================================
 Name        : HMOS_install_notif.c
 Company     : Safran Electronics & Defense
 Version     :
 Copyright   : Safran Electronics & Defense
 Description : This source file defines the API service for notifications during
                install between HEATS and CYCLOPS
 =======================================================================
 */

/**************************************
 * IMPORTED COMPONENTS
 **************************************/
#include <hmos_cyclops_installer.h>
#include <hmos.h>
#include <sys/inotify.h>
#include <string.h>
#include <stdio.h>

/**************************************
 * LOCAL CONST
 **************************************/
// Receive notif config
#define PATH_TO_BE_WATCHED  "/var/notification/to_HEATS"
#define MAX_NB_EVENT        1024 //Maximum number of events to process
#define EVENT_NAME_LENGTH   30   //Assuming that the length of the filename won't exceed 16 bytes
#define EVENT_SIZE          ( sizeof(struct inotify_event) ) //Size of one event
#define BUFFER_LENGTH       ( MAX_NB_EVENT * (EVENT_SIZE + EVENT_NAME_LENGTH) )

// Write notif config
#define MAX_FILE_PATH_SIZE  60
#define PATH_TO_WRITE_NOTIF "/var/notification/from_HEATS"

#define MAX_FILE_NAME_SIZE  30


/**************************************
 * GLOBAL VARIABLES
 **************************************/
/* None */

/**************************************
 * LOCAL VARIABLES
 **************************************/
typedef struct
{
    char *file_name;
    e_hmos_notif_to_heats notif_to_heats;
} s_fileName_notifToHeats_link;

static s_fileName_notifToHeats_link fileName_notifToHeats_table[] = {
    {".RMC_content_file_rdy", HMOS_RMC_content_file_rdy},
    {".RMC_device_removed",   HMOS_RMC_device_removed},
    {".fail_GSM_ON",          HMOS_fail_GSM_ON},
    {".fail_GSM_OFF",         HMOS_fail_GSM_OFF},
    {".success_GSM_ON",       HMOS_success_GSM_ON},
    {".success_GSM_OFF",      HMOS_success_GSM_OFF},
    {".fail_GSM_GETGND",         HMOS_fail_GSM_GETGND},
    {".success_GSM_GETGND",      HMOS_success_GSM_GETGND},
    {".fail_GSM_SEND",        HMOS_fail_GSM_SEND},
    {".success_GSM_SEND",     HMOS_success_GSM_SEND},
    {".fail_openVPN_ON",      HMOS_fail_openVPN_ON},
    {".fail_openVPN_OFF",     HMOS_fail_openVPN_OFF},
    {".fail_FTP_ON",          HMOS_fail_FTP_ON},
    {".fail_FTP_OFF",         HMOS_fail_FTP_OFF},
    {".fail_NTWK",            HMOS_fail_NTWK},
    {".fail_signature_check", HMOS_fail_signature_check},
    {".fail_compat",          HMOS_fail_compat},
    {".fail_dispatcher",      HMOS_fail_dispatcher},
    {".HEATS_files_rdy",      HMOS_HEATS_files_rdy},
    {".eMMC_unknown_dest_pt", HMOS_eMMC_unknown_dest_pt},
    {".eMMC_install_done",    HMOS_eMMC_install_done},
    {".eMMC_install_fail",    HMOS_eMMC_install_fail},
    {".switch_PT_fail",       HMOS_switch_PT_fail},
    {".switch_PT_OK",         HMOS_switch_PT_OK},
    {".install_done",         HMOS_install_done}
    {".fail_SAT_SEND",        HMOS_fail_SAT_SEND},
};

typedef struct
{
    e_hmos_notif_from_heats notif_from_heats;
    char *file_name;
} s_notifFromHeats_fileName_link;

static s_notifFromHeats_fileName_link notifFromHeats_fileName_table[] = {
    {HMOS_ACQ_PWR_transmit_fail,  ".ACQ_PWR_transmit_fail"},
    {HMOS_ACQ_PWR_install_fail,   ".ACQ_PWR_install_fail"},
    {HMOS_ACQ_PWR_install_OK,     ".ACQ_PWR_install_OK"},
    {HMOS_ACQ_PWR_switch_fail,    ".ACQ_PWR_switch_fail"},
    {HMOS_ACQ_PWR_switch_OK,      ".ACQ_PWR_switch_OK"}
};

/**************************************
 * LOCAL PROTOTYPES
 **************************************/
e_hmos_retcode fileName_to_notifToHeats(char *file_name, e_hmos_notif_to_heats *notif_to_heats);

e_hmos_retcode notifFromHeats_to_fileName(char *file_name, e_hmos_notif_from_heats notif_from_heats);

e_hmos_notif_to_heats process_inotify_event(int length, const char *input_buffer);

/* */

/**************************************
 * EXTERNAL FUNCTIONS
 **************************************/

/* Initialise inotify watch */
int HMOS_notif_init ()
{
    int fd;
    int wd;

    /* Initialize inotify */
    fd = inotify_init();
    if (fd == -1)
    {
        HMOS_logPrint(HMOS_LOG_CRIT_ERROR, "%s: inotify_init failed (fd=%d, errno=%d)", __func__, fd, errno);
        HMOS_logPrint(HMOS_LOG_CRIT_NOTICE,"Errno = %d : %s", errno, strerror(errno));
        return -1;
    }

    /* Add Watch */
    wd = inotify_add_watch(fd,PATH_TO_BE_WATCHED,(IN_CREATE|IN_ATTRIB));
    if (wd == -1)
    {
        HMOS_logPrint(HMOS_LOG_CRIT_ERROR, "%s: inotify_add_watch failed (path=%s, wd=%d, errno=%d)", __func__, PATH_TO_BE_WATCHED, wd, errno);
        HMOS_logPrint(HMOS_LOG_CRIT_NOTICE,"Errno = %d : %s", errno, strerror(errno));
        return -1;
    }

    HMOS_logPrint(HMOS_LOG_CRIT_NOTICE,"%s: inotify \"watches\" %s", __func__, PATH_TO_BE_WATCHED);

    return fd;
}

/* Get notification from file descriptor returned by inotify.
 * The notification is an enum */
e_hmos_notif_to_heats HMOS_get_notif (int file_desciptor)
{
    int read_length;
    char event_buffer[BUFFER_LENGTH];
    e_hmos_notif_to_heats notif_received;

    /* read inotify event and handle it */
    read_length = read(file_desciptor, event_buffer, BUFFER_LENGTH);
    if (read_length <= 0)
    {
        HMOS_logPrint(HMOS_LOG_CRIT_ERROR, "%s: error while reading the file descriptor (fd=%d, errno=%d).", __func__, file_desciptor, errno);
        HMOS_logPrint(HMOS_LOG_CRIT_NOTICE,"Errno = %d : %s", errno, strerror(errno));
        return HMOS_error_notif_from_heats;
    }

    /* Process the events which has occurred and select the first one that is correct */
    notif_received = process_inotify_event(read_length, event_buffer);

    return notif_received;
}

/* Send notification to CYCLOPS by creating a file */
e_hmos_retcode HMOS_write_notif (e_hmos_notif_from_heats notif_from_heats)
{
    e_hmos_retcode ret;
    char file_name[MAX_FILE_NAME_SIZE];
    char file_path[MAX_FILE_PATH_SIZE];
    mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP; //0660

    /* Get path from enum */
    ret = notifFromHeats_to_fileName(file_name, notif_from_heats);
    if (ret != HMOS_RETCODE_SUCCESS)
    {
        HMOS_logPrint(HMOS_LOG_CRIT_ERROR, "%s: error, notification not valid (id=%d)", __func__, notif_from_heats);
        return HMOS_RETCODE_ERROR;
    }

    if (snprintf(file_path, MAX_FILE_PATH_SIZE, "%s/%s", PATH_TO_WRITE_NOTIF, file_name) < 0 )
    {
        HMOS_logPrint(HMOS_LOG_CRIT_ERROR, "%s: error while creating full path (path=%s, file=%s)", __func__, PATH_TO_WRITE_NOTIF, file_name);
        return HMOS_RETCODE_ERROR;
    }

    /* Create the file */
    if (creat(file_path, mode) == -1)
    {
        HMOS_logPrint(HMOS_LOG_CRIT_ERROR, "%s: error while creating file (full path=%s, errno=%d)", __func__, file_path, errno);
        HMOS_logPrint(HMOS_LOG_CRIT_NOTICE,"Errno = %d : %s", errno, strerror(errno));
        return HMOS_RETCODE_ERROR;
    }

    HMOS_logPrint ( HMOS_LOG_CRIT_NOTICE, "%s: Notification id=%d created : %s", __func__, notif_from_heats, file_path );
    return HMOS_RETCODE_SUCCESS;
}

/**************************************
 * LOCAL FUNCTIONS
 **************************************/
/* Convert a notification sent to HEATS from string to enum */
e_hmos_retcode fileName_to_notifToHeats(char *file_name, e_hmos_notif_to_heats *notif_to_heats)
{
    int nb_notif = sizeof(fileName_notifToHeats_table)/sizeof(s_fileName_notifToHeats_link);
    for (int i=0; i<nb_notif; i++)
    {
        if (strcmp(fileName_notifToHeats_table[i].file_name, file_name) == 0)
        {
            *notif_to_heats=fileName_notifToHeats_table[i].notif_to_heats;
            return HMOS_RETCODE_SUCCESS;
        }
    }

    return HMOS_RETCODE_ERROR;
}

/* Convert a notification to be sent from HEATS from enum to string */
e_hmos_retcode notifFromHeats_to_fileName(char *file_name, e_hmos_notif_from_heats notif_from_heats)
{
    int nb_notif = sizeof(notifFromHeats_fileName_table)/sizeof(s_notifFromHeats_fileName_link);
    for (int i=0; i<nb_notif; i++)
    {
        if (notifFromHeats_fileName_table[i].notif_from_heats == notif_from_heats)
        {
            snprintf(file_name, MAX_FILE_NAME_SIZE, "%s", notifFromHeats_fileName_table[i].file_name);
            return HMOS_RETCODE_SUCCESS;
        }
    }
    return HMOS_RETCODE_ERROR;
}

/* Return the first valid event from the input buffer */
e_hmos_notif_to_heats process_inotify_event(int length, const char *input_buffer)
{
    int i=0;
    e_hmos_retcode ret;
    e_hmos_notif_to_heats notif;

    /* Loop through the events in input buffer */
    while (i < length)
    {
        struct inotify_event *event = (struct inotify_event *) &input_buffer[i];

        if(event->len)
        {
			if ( ! (event->mask & IN_ISDIR) && (event->mask & (IN_CREATE|IN_ATTRIB)) )
            {
                /* Get the correct enum from the inotify event */
                ret = fileName_to_notifToHeats(event->name, &notif);
                if (ret == HMOS_RETCODE_SUCCESS)
                {
                  HMOS_logPrint ( HMOS_LOG_CRIT_NOTICE, "%s: notif received : %d -> %s", __func__, notif, event->name );
				  /* remove the notification file */
				  char file_path[MAX_FILE_PATH_SIZE];
				  snprintf(file_path, MAX_FILE_PATH_SIZE, "%s/%s", PATH_TO_BE_WATCHED, event->name);
				  remove(file_path);
                  return notif;
                }

                HMOS_logPrint(HMOS_LOG_CRIT_ERROR, "%s: invalid notif : %s", __func__, event->name);

                /* No corresponding enum found, continue to search */
            }
        }
        i += EVENT_SIZE + event->len;
    }

    /* Nothing found in the input buffer */
    HMOS_logPrint(HMOS_LOG_CRIT_ERROR, "%s: error, no valid notification found", __func__);
    return HMOS_error_notif_to_heats;
}
