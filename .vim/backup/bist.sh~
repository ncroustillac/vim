#!/bin/bash
# Description: Self testing HV3
# Testing SAT, wifi, GSM modules responses

BIST_RESULT="/containers/container-as/var/bist"
GSM_AT_PORT="/dev/ttyUSB0"

############################################
# Error message handler
############################################
err() {
  printf "%s\\n" "$@" >&2
}

############################################
# Device detection loop, waiting for a max
# of 30 sec until the nodes are created
# Input:
#   - device path string
# Output:
#   0 : succes, device node was created
#   1 : failed, no device node appeared
############################################
wait_for_device() {

  for ((t=0; t<30; t++))
  {
    if [[ -e $1 ]];then
      printf "%s found\\n" "$1"
      return 0
    else
      sleep 1
    fi
  }
  err "Could not detect %s" "$1"
  return 1
}

############################################
# Read UTC from GSM AT serial port
# Output:
#   0 : succes, time is set
#   1 : failed, could't set time
############################################
get_utc() {

  at_ok=0
  # A named pipe to control the process writing to the AT PORT
  mkfifo at_fifo
  # Forked process A to send AT command as long as we write 0 to
  # the pipe. Stops when we send 1
  while true; do

    fifo_msg=$(cat at_fifo)

    if [[ "$fifo_msg" == "1" ]];then
      break
    else
      echo "AT+CCLK?" > /dev/ttyUSB0
      sleep 0.5
    fi
  done &

  # Tell process A to send a first AT command
  echo "0" > at_fifo
  # Here we loop reading the AT port and requesting process A to send
  # AT commands until we recievie a OK in the string
  # Timeout is set to 10s if no response is coming from modem
  while read -rs -t 10 at_response; do

    if [[ $at_response == *"CCLK:"* ]];then
      at_ok=1
      #Stop sending the AT Command
      echo "1" > at_fifo
      break
    elif [[ $at_response == *"ERROR"* ]];then
      at_ok=0
      #Resend the AT command
      echo "0" > at_fifo
    fi
  done < /dev/ttyUSB0

  # When OK was detected we parse the String and set the time
  if [[ $at_ok = 1 ]];then

    utc="${at_response#*\"}"
    utc="${utc%+*}"
    at_date="${utc%,*}"
    at_time="${utc#*,}"
    at_year="$((2000+${at_date:0:2}))"
    at_month="${at_date:3:2}"
    at_day="${at_date:6:2}"

    date "${at_year}-${at_month}-${at_day} ${at_time}"

    result=$?

    if [[ result -eq 0 ]];then
      printf "GSM time set %s - %s" "$at_date" "$at_time"
    else
      err "Could not retrieve time from GSM broadcast"
    fi

  else
    err "Module didn't answer in time"

  fi
}
#############################################
# Activate the GSM module to test for its
# presence and retrive UTC from serial AT
# port
#############################################
test_gsm_module() {

  #Turn on GSM module
  hv3gpio -g on

  #Check if Module turns ON
  wait_for_device $GSM_AT_PORT
  result="$?"

  if [[ $result -eq 1 ]];then
    err "GSM modem failed"
    return 1
  fi

  # Give time to the modem and start requesting UTC time
  sleep 1
  get_utc

  #Turn off GSM module
  hv3gpio -g off
  return 0
}

main() {

  rm -f $BIST_RESULT

  #Run GSM TEST
  test_gsm_module "$@"
  gsm_result=$?
  if [[ $gsm_result -eq 0 ]];then
    printf "GSM=OK\\n" >> $BIST_RESULT
  else
    printf "GSM=N\\n" >> $BIST_RESULT
  fi

  /usr/services/sat-control/sat-control poke
  sat_result=$?
  if [[ "${sat_result}" -eq 0 ]];then
    printf "SAT=OK\\n" >> $BIST_RESULT
  else
    printf "SAT=N\\n" >> $BIST_RESULT
  fi


  [[ ! -z "$(ip l | grep "wlan0")" ]]
  wifi_result=$?
  if [[ "${wifi_result}" -eq 0 ]];then
    printf "WIFI=OK\\n" >> $BIST_RESULT
  else
    printf "WIFI=N\\n" >> $BIST_RESULT
  fi
  
  if [[ "${gsm_result}" -eq "1"     ||      \
        "${sat_result}" -eq "1"     ||      \
        "${wifi_result}" -eq "1"    ]];then
  fi
}

main "$@"
