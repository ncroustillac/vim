#!/bin/sh

set -x 
# This daemon is used to replace systemd.path for signaturechecker.
# It listen to the LISTEN_PATH and wait for a folder to be created. Once
# a folder is created, a sub daemon is launched to monitor it more closely.

# Systemd.path files are not able to convey the level of granularity we need
# to perform the following functions, since we need multiple level of folder and
# files to monitor

SC_KEEP_ALIVE_DELAY=@SC_KEEP_ALIVE_DELAY@
SC_FILE_KEEPALIVE="@SC_FILE_KEEPALIVE@" #Signature Checker "KeepAlive" message
SC_WAIT_FILES_MAXIMUM_DELAY=180

LISTEN_PATH="@DLAGENT_UPLOAD_PATH@"
SIG_FILE_EXT="@SIG_FILE_EXT@"

# Lock
FLOCK_FD=5
FLOCK_FILE=/var/services/signaturechecker/sigcheck-daemon.lock

TEMP_PATH="@SIGCHECK_TEMP_PATH@"
DLAGENT_FIFO="@DLAGENT_FIFO_PATH@"

readonly TC_STD="\\033[0;39m"
readonly TC_RED="\\033[1;31m"

# Display an error message
f_error()
{
  echo -e "${TC_RED}ERROR: (Func:"${FUNCNAME[1]}" ; Line:"${BASH_LINENO[0]}") ${g_padding}$@${TC_STD}"
}

f_process()
{
    local l_file="$1"
    local l_target="$2"
    local l_params="$3"
    local l_file_dirname
    local l_tempfulldir
    local l_filefinalpath

    # Take lock to ensure no multiple instances working on the same file
    echo "Processing ${l_target} file ${l_file}"
    # if file is not .done, wait for the file.done to appear and then continue
    while [ -z "$(ls "${l_file}.done" 2>/dev/null)" ]; do sleep 0.2; done
    rm -f "${l_file}.done"

    mkdir -p "$(dirname ${FLOCK_FILE})"
    eval "exec ${FLOCK_FD}>${FLOCK_FILE}"
    flock -x ${FLOCK_FD}

    # Get file to work with
    l_file_dirname="$(basename $(dirname ${l_file}))"
    l_tempfulldir="${TEMP_PATH}/${l_file_dirname}"
    l_filefinalpath="${l_tempfulldir}/$(basename ${l_file})"

    # Mv file in pending box
    mkdir -p "${l_tempfulldir}"
    mv "${l_file}" "${l_filefinalpath}"

    # Call sigchecker with file in parameter :
    #   The file is automatically moved to its destination
    eval "/usr/services/signaturechecker/signaturechecker.sh ${l_target} --file ${l_filefinalpath} ${l_params}"

    # Release lock
    flock -u ${FLOCK_FD}
}

f_treatfile()
{
    local l_file="$1"
    if [ ! -f "${l_file}" ] || [ ! -z "$(echo "${l_file}" | grep ".done")" ]; then
      # If the returned param is not a file, or has the extension for ".done" files, then ignore
      return
    fi

    if [ -z "$(echo ${l_file} | grep -E ".*${SIG_FILE_EXT}")" ]; then
      # File is an fls file
      # Give a slight delay for file to not take to lock imediatly (the delay is absorbed eitherway by the time of execution of signaturechecker)
      sleep 0.3
      f_process "${l_file}" "file" "--fifo ${DLAGENT_FIFO}"
    else
      # File is a SIF
      #We do not give "--fifo ${DLAGENT_FIFO}" for SIF files. Those files are not validated by SignatureChecker but by DateChecker, which will write to ${DLAGENT_FIFO}
      f_process "${l_file}" "signature"
    fi
}

f_startKeepAliveLoopFifo()
{
    while true; do
        echo -ne "${SC_FILE_KEEPALIVE}" > ${DLAGENT_FIFO}
        sleep ${SC_KEEP_ALIVE_DELAY}
    done
}

f_daemon()
{
    local l_keep_alive
    local l_object
    local l_ret=0
    local l_found="false"
    local l_starting=true

    #Start sending "keep alive" packets to dlagent (if not, dlagent will fail)
    #f_startKeepAliveLoopFifo &
    l_keep_alive=$!

    # Loop for new files created in the LISTEN_PATH
    # Stop sending "Keep Alive" packets and exit if no new files have been written in ${LISTEN_PATH} since ${SC_WAIT_FILES_MAXIMUM_DELAY} second.
    inotifywait -r -e close_write ${LISTEN_PATH} --format=%w%f -mq | while read l_file; do { f_treatfile "${l_file}" & disown; } ; done
}

f_daemon
