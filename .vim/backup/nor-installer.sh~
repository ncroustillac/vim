#! /bin/bash
# =============================================================================
# Title           : NAND installer
# Description     : NAND installer module to store incomming FLS
# Author          : Cedric Berland <cedric.berland@safrangroup.com>
# Version         : 0.1
###############################################################################

# -----------------------------------------------------------------------------
# Text syntax
# -----------------------------------------------------------------------------

# Bold
readonly TC_BOLD="\033[1m"

# Colors
readonly TC_STD="\\033[0;39m"
readonly TC_GRE="\\033[1;32m"
readonly TC_RED="\\033[1;31m"
readonly TC_BLU="\\033[1;96m"
readonly TC_WHI="\\033[1;97m"
readonly TC_YEL="\\033[1;33m"

# -----------------------------------------------------------------------------
# Functional
# -----------------------------------------------------------------------------

# Exitcode: Catchall for general errors
readonly EXIT_OK=0

# Exitcode: Catchall for general errors
readonly EXIT_ERR_DEFAULT=1

# Exitcode: Command not found
readonly EXIT_ERR_EXE=127

# Default exitcode in case of fatal error
readonly DEFAULT_ERROR_EXIT_CODE="${EXIT_ERR_DEFAULT}"

# Global Debug level
readonly DEBUG_LEVEL="0"

# =============================================================================
#  GLOBALS (Do not modify)
# =============================================================================
# Note   : This section declares the used globals and their initial values.
#          A modification of this section may cause unexpected behaviour in the
#          execution of the code.
# Syntax :
#          # Global variable
#          g_variable_name="value"
#
#          # Global constant
#          readonly CONSTANT_NAME="value"
#
#          # Later-on initialized constants
#          G_constant_name=""                 # < Initialize empty variable
#          (...)                              #
#          G_constant_name="initialization"   # < Value may change during
#          (...)                              # < a specific part of the code.
#          G_constant_name="otherValue"       # <
#          (...)                              #
#          readonly G_constant_name           # < Variable becomes constant
# =============================================================================

# -----------------------------------------------------------------------------
# Global constants
# -----------------------------------------------------------------------------

readonly SCRIPT_NAME="$(basename $0)"
readonly SCRIPT_DIRECTORY="$(dirname $(realpath $0))"

# -----------------------------------------------------------------------------
# Global variables
# -----------------------------------------------------------------------------

# Contains the script exit code in case of failure
g_exitcode="0"

# -----------------------------------------------------------------------------
# Later-on initialized constants
# -----------------------------------------------------------------------------

# Debug level (can be modified during code)
G_debuglevel="0"

# Paths used during process
G_fifoPath=""

# Path containing all FLS to install
G_ListenPath="@NOR_INSTALLER_LISTEN_PATH@"

# Path containing SIF
G_SIFPath="@SIGNATURECHECKER_SIF_PATH@"

# Boolean on weither the hash sheck is done or not
G_HashEnabled="@NOR_INSTALLER_HASH_ENABLED@"

# Extention of the hash file (eg. "file.itb.sha256")
G_HashFileExtention="@NOR_INSTALLER_HASH_FILE_EXTENTION@"

# Algo used to calculate hash with openssl (eg. sha256)
G_HashAlgo="@NOR_INSTALLER_HASH_ALGO@"

# Extention of the hash file (eg. "file.itb.sha256")
G_OtherAllowedFileExtention="@NOR_INSTALLER_OTHER_ALLOWED_FILE_EXTENTION@"

# =============================================================================
#  Include Project Specific Script
# =============================================================================

source ${SCRIPT_DIRECTORY}/nor-installer_specific.sh

# =============================================================================
#  FUNCTIONS
# =============================================================================

# Display a fatal error message and exit process
f_fatal()
{
  echo -e "${TC_RED}(Func:${FUNCNAME[1]} ; Line:${BASH_LINENO[0]}) FATAL: $@${TC_STD}"

  # Set default error exit code
  if [ "${g_exitcode}" = "0" ]; then
    g_exitcode="${DEFAULT_ERROR_EXIT_CODE}"
  fi

  exit ${g_exitcode}
}

# Display an error message
f_error()
{
  echo -e "${TC_RED}(Func:${FUNCNAME[1]} ; Line:${BASH_LINENO[0]}) ERROR: $@${TC_STD}"
}

# Display a warning message
f_warn()
{
  echo -e "${TC_YEL}(Func:${FUNCNAME[1]} ; Line:${BASH_LINENO[0]}) WARN: $@${TC_STD}"
}

# Display a notice message
f_notice()
{
  echo -e "${TC_BLU}(Func:${FUNCNAME[1]} ; Line:${BASH_LINENO[0]}) NOTE: $@${TC_STD}"
}

f_log_secu_notice()
{
  logger -p local2.notice $@
}

f_log_secu_error()
{
  logger -p local2.err $@
}

# Display a debug message
f_debug()
{
  local l_level="$1"
  shift

  # Check if the first value is a number
  if ! [[ ${l_level} =~ ^[0-9]+$ ]] ; then
    f_fatal "The first argument of f_debug must be a number"
  fi

  if [ ${l_level} -le ${DEBUG_LEVEL} ] || [ ${l_level} -le ${G_debuglevel} ]; then
    echo -e "${TC_WHI}(Func:${FUNCNAME[1]} ; Line:${BASH_LINENO[0]}) DEBUG: $@${TC_STD}"
  fi
}

# Display a green message
f_ok()
{
  echo -e "${TC_GRE}(Func:${FUNCNAME[1]} ; Line:${BASH_LINENO[0]}) $@${TC_STD}"
}

# Display a red message
f_ko()
{
  echo -e "${TC_RED}(Func:${FUNCNAME[1]} ; Line:${BASH_LINENO[0]}) $@${TC_STD}"
}

# -----------------------------------------------------------------------------
#  Init: usage, tools check and argument parsing
# -----------------------------------------------------------------------------

# Display the script's usage
f_usage()
{
    echo -e "\
${TC_BOLD}NAME${TC_STD}
    ${SCRIPT_NAME} - SHORT DESCRIPTION

${TC_BOLD}SYNOPSIS${TC_STD}
    ${SCRIPT_NAME} [OPTIONS] ARGUMENT1 ARGUMENT2

${TC_BOLD}DESCRIPTION${TC_STD}
    LONGER DESCRIPTION

${TC_BOLD}OPTIONS${TC_STD}
    --help|-h            : Print help
    --debug LEVEL        : Set debug level to LEVEL
    "
}

f_argsParse()
{
  while [ $# -gt 0 ]; do
    case $1 in
      --help|-h)
        f_usage
        exit ${EXIT_OK}
        ;;
      --debug)
        G_debuglevel="$2"
        shift 2
        ;;
      --fifo)
        G_fifoPath="$2"
        shift 2
        ;;
      -*)
        f_fatal "Unsupported operation: $1"
        shift
        ;;
      *)
        f_fatal "Unexpected argument: $1"
        shift
        ;;
    esac
  done

  readonly G_debuglevel
}

# -----------------------------------------------------------------------------
#  Core functions
# -----------------------------------------------------------------------------

# Copy all paths in --from to all paths in --to
# and once done, advert to all paths in --fifo either OK or KO

# fifo messages :
# 0\0 : In progress
# 1\0 : OK
# 2\0 : KO
f_sendToFifo()
{
    local l_message="$1"
    local l_fifo

    if [ -z "${G_fifoPath}" ]; then
        f_warn "No fifo to process. No status will be sent."
        return
    fi

    for l_fifo in "${G_fifoPath}"; do
        if [ -p "${l_fifo}" ]; then
            f_notice "Sending status \"${l_message}\" to FIFO \"${l_fifo}\"."
            echo -ne "\x0${l_message}\0" >> "${l_fifo}"
        else
            f_warn "Following path \"${l_fifo}\" is not a FIFO or does not exist. Cannot send status."
        fi
    done
}

f_checkHash()
{
    local l_loadFile="$1"
    local l_hashFile="$2"
    local l_ret=0

    local l_calculatedHash
    local l_retrievedHash

    f_notice "Checking Hash of load File"

    # Retrieve hash with openssl
    l_calculatedHash="$(openssl dgst -${G_HashAlgo} -r ${l_loadFile} | cut -d' ' -f 1)"

    if [ -z "${l_calculatedHash}" ]; then
        f_error "Error during calculation of hash file '${l_calculatedHash}'"
        l_ret=1
    fi

    if [ "${l_ret}" = "0" ]; then
        # Retrived first word of hash File
        l_retrievedHash="$(cat "${l_hashFile}" | awk '{print $1}')"
        if [ -z "${l_retrievedHash}" ]; then
            f_error "Error retrieving the hash in file '${l_hashFile}'"
            l_ret=1
        fi
    fi

    if [ "${l_ret}" = "0" ]; then
        if [ "${l_calculatedHash}" = "${l_retrievedHash}" ]; then
            f_notice "Hash correctly calculated for load file '${l_loadFile}'"
        else
            f_error "Error comparing calculated hash '${l_calculatedHash}' with retrieved hash '${l_retrievedHash}' for file '${l_loadFile}'"
            l_ret=1
        fi
    fi

    return ${l_ret}
}

f_checkHashStored()
{
    local l_fls="$1"
    local l_hashFile="$2"
    local l_ret=0

    local l_storedHash
    local l_storedHashFunction
    local l_retrievedHash

    f_notice "Checking Hash after NOR install"

    # Compare hash of loadFile with the hash stored in hashFile
    l_storedHashFunction="$(pttools table read ${l_fls} --field hashalgo --text inactive)"
    l_storedHash="$(pttools table read ${l_fls} --field hash --text inactive)"

    if [ -z "${l_storedHash}" ]; then
        f_error "Could not retrieved hash in NOR '${l_storedHash}'"
        l_ret=1
    fi

    # TODO add more hash function
    case "${l_storedHashFunction}" in
      "sha256")
          l_storedHash="$(echo ${l_storedHash} | cut -b -64)"
          ;;
      "sha512")
          l_storedHash="$(echo ${l_storedHash} | cut -b -128)"
          ;;
      *)
        f_error "Unknown hashalgo '${l_storedHashFunction}' retrieved."
        l_ret=1
    esac

    if [ "${l_ret}" = "0" ]; then
        # Retrived first word of hash File
        l_retrievedHash="$(cat "${l_hashFile}" | awk '{print $1}')"
        if [ -z "${l_retrievedHash}" ]; then
            f_error "Error retrieving the hash in file '${l_hashFile}'"
            l_ret=1
        fi
    fi

    if [ "${l_ret}" = "0" ]; then
        if [ "${l_storedHash}" = "${l_retrievedHash}" ]; then
            f_notice "Hash correctly calculated for fls '${l_fls}'"
        else
            f_error "Error comparing NOR hash '${l_storedHash}' with retrieved hash '${l_retrievedHash}' for fls '${l_fls}'"
            l_ret=1
        fi
    fi

    return ${l_ret}
}

f_processFile()
{
    local l_fls=$1
    local l_loadFile="$2"
    local l_hashFile="$3"
    local l_ret=0
    local l_slot=0
    local l_slot_check

    if [ "${G_HashEnabled}" = "1" ]; then
        f_checkHash "${l_loadFile}" "${l_hashFile}"
        l_ret=$?
    fi

    if [ "${l_ret}" = "0" ]; then
        f_notice "Installing FLS '${l_fls}' in NOR"

        # Install the load using pttools
        # Check that the FLS is in the fls list of pttools
        if [ -z "$(pttools -l | grep "${l_fls}")" ]; then
            f_error "Could not find '${l_fls}' in the return value of 'pttools -l'."
            l_ret=1
        else
            # The fls is indeed manageable using pttools

            # The inactive partTable was previously copied from the current partTable
            # The slot need to be switched for the flip flop to be effective
            l_slot="$(pttools table read ${l_fls} --field slot --text active)"
            if [ "${l_slot}" != "1" ] && [ "${l_slot}" != "2" ]; then
                # By default, if slot is undefined, use slot 1
                l_slot="1"
            else
                # Switch the slot to the inactive one
                l_slot="$(((${l_slot} % 2) + 1))"
            fi
            # Update the inactive part table for fls to the new slot
            echo "${l_slot}" | pttools table write ${l_fls} --field slot --text inactive
            l_slot_check="$(pttools table read ${l_fls} --field slot --text inactive)"
            if [ "${l_slot_check}" = "${l_slot}" ]; then
                # Slot updated successfully : proceed to the install of the load file
                pttools partition write ${l_fls} --input "${l_loadFile}" inactive

                if [ "${G_HashEnabled}" = "1" ]; then
                    f_checkHashStored "${l_fls}" "${l_hashFile}"
                    l_ret=$?
                fi
            else
                f_error "Incorect slot found '${l_slot_check}' '${l_slot}'"
                l_ret=1
            fi

        fi
    fi

    return ${l_ret}
}

f_processDir()
{
    local l_fls=$1
    local l_flsDir="$2"
    local l_allowed_extention_regexp=""
    local l_loadFile
    local l_hashFile
    local l_allowedFile
    local l_ret=0

    if [[ ! "${G_OtherAllowedFileExtention}" =~ ^([ ]*)$ ]]; then
        #G_OtherAllowedFileExtention is not empty and it does not contain only spaces char

        #if G_OtherAllowedFileExtention=".toto .titi .tata", then l_allowed_extention_regexp="(.*.toto)|(.*.titi)|(.*.tata)|"
        l_allowed_extention_regexp="$(printf '(.*%s)|' ${G_OtherAllowedFileExtention})"
    fi

    # There must be one load file, its sha file. If there is other file (ex: .cmp file), their extentions need to appear in G_OtherAllowedFileExtention.
    l_allowedFiles="$(find "${l_flsDir}" -type f -regextype posix-extended -regex "${l_allowed_extention_regexp}")"
    l_hashFile="$(find "${l_flsDir}" -type f -name "*${G_HashFileExtention}")"
    l_loadFile="$(find "${l_flsDir}" -type f -not -name "*${G_HashFileExtention}" -regextype posix-extended -not -regex "${l_allowed_extention_regexp}")"

    f_debug 1 "LoadFile: '${l_loadFile}', HashFile: '${l_hashFile}'"
    [ -n "${l_allowedFiles}" ] && f_debug 1 "OtherAllowedFiles: '${l_allowedFiles}'"

    if [ "$(echo "${l_loadFile}" | wc -w )" != "1" ]; then
        f_error "Incorect number of files found in '${l_flsDir}'. There should be stritly one load file."
        f_error "Found files : '${l_loadFile}'"
        l_ret=1
    fi

    if [ "${l_ret}" = "0" ]; then
        if [ "${G_HashEnabled}" = "1" ]; then
            if [ "$(echo "${l_hashFile}" | wc -w )" != "1" ]; then
                f_error "Hash verification is enabled, yet no hash file found. hashFile value : '${l_hashFile}'."
                l_ret=1
            fi
        fi
    fi

    if [ "${l_ret}" = "0" ]; then
        f_processFile "${l_fls}" "${l_loadFile}" "${l_hashFile}"
        l_ret=$?
    fi

    #specific process for load file
    if [ "${l_ret}" = "0" ]; then
        f_processFileSpecific "${G_debuglevel}" "${l_fls}" "${l_loadFile}" "${l_hashFile}"
        l_ret=$?
    fi

    #specific process for other allowed files
    if [ "${l_ret}" = "0" ]; then
        for l_allowedFile in ${l_allowedFiles}; do
            f_processFileSpecific "${G_debuglevel}" "${l_fls}" "${l_allowedFile}"
            l_ret=$?
            if [ ${l_ret} -ne 0 ]; then
                break
            fi
        done
    fi

    return ${l_ret}
}

f_processFLS()
{
    local l_fls=$1
    local l_flsDir="${G_ListenPath}/${l_fls}"
    local l_ret=0

    if [ ! -d "${l_flsDir}" ]; then
        f_error "Path \"${l_flsDir}\" is not a directory or does not exist."
        l_ret=1
    else
        if [ -z "$(ls ${l_flsDir})" ]; then
            f_error "Following directory \"${l_flsDir}\" is empty."
            l_ret=1
        else
            f_notice "Processing FLS '${l_fls}' from directory '${l_flsDir}'"
            f_processDir "${l_fls}" "${l_flsDir}"
            if [ "$?" = "0" ]; then
                f_notice "Copy is done, removing files in \"${l_flsDir}\""
                rm -rf "${l_flsDir}"
            else
                f_error "Error during processing of fls '${l_fls}'. Leaving files in '${l_flsDir}' untouched."
                l_ret=1
            fi
        fi
    fi
    return ${l_ret}
}

f_getCurrentPart()
{
    local l_current=0
    local l_partone="$(ptstatustools -n 1 -s)"
    local l_parttwo="$(ptstatustools -n 2 -s)"

    if [ "${l_partone}" = "GOOD" ]; then
        l_current=1
    elif [ "${l_parttwo}" = "GOOD" ]; then
        l_current=2
    elif [ "${l_partone}" = "BACKUP" ]; then
        l_current=1
    elif [ "${l_parttwo}" = "BACKUP" ]; then
        l_current=2
    else
        f_error "No partition in either GOOD or BACKUP. Cannot install in NOR"
        l_current=0
    fi

    return ${l_current}
}

# G_fifoPath may be empty
f_main()
{
    local l_status=0
    local l_cpt=0
    local l_fls
    local l_ret

    f_sendToFifo "0"

    f_getCurrentPart
    local l_current="$?"
    local l_inactive
    if [ "${l_current}" = "1" ] || [ "${l_current}" = "2" ]; then
        l_inactive="$(((${l_current} % 2) + 1))"
        f_notice "Current parttable is '${l_current}', inactive is '${l_inactive}'."
    else
        f_error "Could not determine current part table. Aborting (l_current = ${l_current})."
        l_status=1
    fi

    if [ "${l_status}" = "0" ]; then
        # Set inactive part table to FAILED
        ptstatustools -n "${l_inactive}" -x "FAILED"
        if [ "$?" != "0" ]; then
            f_error "Could not set inactive part table to FAILED."
            l_status=1
        fi
    fi

    if [ "${l_status}" = "0" ]; then
        # Set active part table to BACKUP
        ptstatustools -n "${l_current}" -x "BACKUP"
        if [ "$?" != "0" ]; then
            f_error "Could not set active part table to BACKUP."
            l_status=1
        fi
    fi

    if [ "${l_status}" = "0" ]; then
        f_notice "Copying current part table contents to the inactive one"
        rm -rf "/var/services/nor-installer/tmp.partTable"
        pttools table read FULLTABLE --output "/var/services/nor-installer/tmp.partTable" active
        if [ "$?" != "0" ]; then
            f_error "Could not retrieve the current part table"
            l_status=1
        fi
        if [ "${l_status}" = "0" ]; then
            pttools table write FULLTABLE --input "/var/services/nor-installer/tmp.partTable" inactive
            if [ "$?" != "0" ]; then
                f_error "Could not update inactive part table"
                l_status=1
            fi
        fi
    fi

    if [ "${l_status}" = "0" ]; then
        # Since FLS folder are erased after being processed, the loop should end
        while [ ! -z "$(ls "${G_ListenPath}")" ] && [ "${l_status}" = "0" ]; do
            for l_fls in $(ls "${G_ListenPath}"); do
                # Keep sending "IN PROGRESS" status
                f_sendToFifo "0"

                f_processFLS "${l_fls}"
                l_ret=$?
                if [ "${l_ret}" != "0" ]; then
                    l_status=1
                    f_log_secu_error "Load ${l_fls} could not be installed"
                    break
                else
                    f_log_secu_notice "Load ${l_fls} was installed successfuly"
                fi
                l_cpt=$((${l_cpt} + 1))
            done
        done
        # Wait to see if new folder are appearing
        sleep 2
    fi

    if [ "${l_status}" = "0" ]; then
        # Set fresh count
        ptstatustools -y "@FRESHCOUNT_TRIES@"
        if [ "$?" != "0" ]; then
            f_error "Could not set freshcount."
            l_status=1
        fi
    fi

    if [ "${l_status}" = "0" ]; then
        # Set inactive part table to FRESH
        ptstatustools -n "${l_inactive}" -x "FRESH"
        if [ "$?" != "0" ]; then
            f_error "Could not set inactive part table to FRESH."
            l_status=1
        fi
    fi

    # Make sure we deleted all remaining folders
    rm -rf "${G_ListenPath}/*"

    # For each FLS we have to send a status
    if [ "${l_status}" = "0" ]; then
        # If no error occured, send OK to FIFO (as many as the number of FLS stored)
        for inc in $(seq 1 ${l_cpt}); do
            f_sendToFifo "1"
            sleep 1
        done
    else
        # If at least one error occured, send KO
        f_sendToFifo "2"
    fi

    return ${l_status}
}



# =============================================================================
#  MAIN
# =============================================================================
# Note   : This section contains the script's main call.
# =============================================================================

# Initiate the arguments parsing
f_argsParse "$@"

f_main

if [ "$?" = "0" ]; then
    # If no error occured at all
    f_notice "All loads correctly installed."
    exit ${EXIT_OK}
else
    # If at least one error occured
    f_error "At least one load was in error"
    exit ${EXIT_ERR_DEFAULT}
fi
