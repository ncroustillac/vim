#! /bin/bash
# =============================================================================
# Title           : Signature Checker Wrapper script
# Description     : Script providing arguments to the signaturechecker executable
# Author          : Cedric Berland <cedric.berland@safrangroup.com>
# Version         : 1.0
# Help            : --help -h
###############################################################################
set -x

# =============================================================================
#  CONFIGURATION
# =============================================================================

# -----------------------------------------------------------------------------
# Inputs
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Defaults
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Text syntax
# -----------------------------------------------------------------------------

# Bold
readonly TC_BOLD="\033[1m"

# Colors
readonly TC_STD="\\033[0;39m"
readonly TC_GRE="\\033[1;32m"
readonly TC_RED="\\033[1;31m"
readonly TC_BLU="\\033[1;36m"
readonly TC_WHI="\\033[1;38m"
readonly TC_YEL="\\033[1;33m"

# -----------------------------------------------------------------------------
# Functional
# -----------------------------------------------------------------------------

# Exitcode: Catchall for general errors
readonly EXIT_OK=0

# Exitcode: Catchall for general errors
readonly EXIT_ERR_DEFAULT=1

# Exitcode: Command not found
readonly EXIT_ERR_EXE=127

# Default exitcode in case of fatal error
readonly DEFAULT_ERROR_EXIT_CODE="${EXIT_ERR_DEFAULT}"

# Global Debug level
readonly DEBUG_LEVEL="0"

SC_FILE_OK="@SC_FILE_OK@" #Signature Checker "OK" message
SC_FILE_KO="@SC_FILE_KO@" #Signature Checker "Error" message

# =============================================================================
#  GLOBALS (Do not modify)
# =============================================================================
# Note   : This section declares the used globals and their initial values.
#          A modification of this section may cause unexpected behaviour in the
#          execution of the code.
# Syntax :
#          # Global variable
#          g_variable_name="value"
#
#          # Global constant
#          readonly CONSTANT_NAME="value"
#
#          # Later-on initialized constants
#          G_constant_name=""                 # < Initialize empty variable
#          (...)                              #
#          G_constant_name="initialization"   # < Value may change during
#          (...)                              # < a specific part of the code.
#          G_constant_name="otherValue"       # <
#          (...)                              #
#          readonly G_constant_name           # < Variable becomes constant
# =============================================================================

# -----------------------------------------------------------------------------
# Global constants
# -----------------------------------------------------------------------------

readonly SCRIPT_NAME="$(basename ${BASH_SOURCE[0]})"
readonly SCRIPT_DIRECTORY="$(dirname $(realpath ${BASH_SOURCE[0]}))"
readonly PADSTR="| -- "


readonly G_DEFAULT_CONF_PATH="/usr/services/signaturechecker/signaturechecker_conf.sh"

# -----------------------------------------------------------------------------
# Global variables
# -----------------------------------------------------------------------------

# Contains the script exit code in case of failure
g_exitcode="0"

# Padding for display
g_padding=""

# -----------------------------------------------------------------------------
# Later-on initialized constants
# -----------------------------------------------------------------------------

# Debug level (can be modified during code)
G_debuglevel="0"

# Configuration path (can be modified during code)
G_configPath="${G_DEFAULT_CONF_PATH}"

# File to check (mandatory)
G_ToCheckFile=""

# FIFO for sending status
G_fifo=""

# Verbose mode
G_verbose=false

# =============================================================================
#  FUNCTIONS
# =============================================================================
# Note   : This section declares local functions.
#          Functions must declare their local variables using the "local"
#          shell directive.
# Syntax : f_myfunctionname()
#          {
#            local l_exitcode="0"
#            local l_functionargument1="$1"
#            local l_functionargument2="$2"
#            local l_localvariablename1="initialvalue"
#            local l_localvariablename2=""
#            readonly local l_localconstantname="initialconstantvalue"
#
#            # Functional here
#            (...)
#
#            return ${l_exitcode}
#          }
# =============================================================================

# -----------------------------------------------------------------------------
#  Tools
# -----------------------------------------------------------------------------

# Display a fatal error message and exit process
f_fatal()
{
  echo -e "${TC_RED}FATAL: (Func:"${FUNCNAME[1]}" ; Line:"${BASH_LINENO[0]}") ${g_padding}$@${TC_STD}"

  # Set default error exit code
  if [ "${g_exitcode}" = "0" ]; then
    g_exitcode="${DEFAULT_ERROR_EXIT_CODE}"
  fi

  f_projectFailSigCheck
  exit ${g_exitcode}
}

# Display an error message
f_error()
{
  echo -e "${TC_RED}ERROR: (Func:"${FUNCNAME[1]}" ; Line:"${BASH_LINENO[0]}") ${g_padding}$@${TC_STD}"
}

# Display a warning message
f_warn()
{
  echo -e "${TC_YEL}WARN : ${g_padding}$@${TC_STD}"
}

# Display a notice message
f_notice()
{
  echo -e "${TC_WHI}NOTE : ${g_padding}$@${TC_STD}"
}

# Display a debug message
f_debug()
{
  local l_level="$1"
  shift

  # Check if the first value is a number
  if ! [[ ${l_level} =~ ^[0-9]+$ ]] ; then
    f_fatal "The first argument of f_debug must be a number"
    f_projectFailSigCheck
    exit 1
  fi

  if [ ${l_level} -le ${DEBUG_LEVEL} ] || [ ${l_level} -le ${G_debuglevel} ]; then
    echo -e "${TC_BLU}DEBUG: ${g_padding}$@${TC_STD}"
  fi
}

# Execute if verbose
f_ifverb()
{
  ${G_verbose} && $@
}

# Execute if not verbose
f_ifnverb()
{
  ${G_verbose} || $@
}

# Increase padding in displayed messages
f_padup()
{
  # Replace previous
  g_padding="$(echo "${g_padding}" | sed "s/./ /g")"
  g_padding="${g_padding}${PADSTR}"
}

# Decrease padding in displayed messages
f_paddown()
{
  local l_padstrnum="${#PADSTR}"

  if [ -z "${g_padding}" ]; then
    # Empty string, nothing to be done
    return
  fi

  # Remove last pad
  g_padding=${g_padding:0:${#g_padding}-${l_padstrnum}}

  # Check if there is still characters
  if [ -z "${g_padding}" ]; then
    # Empty string, nothing to be done
    return
  fi

  # Remove and append PADSTR
  g_padding=${g_padding:0:${#g_padding}-${l_padstrnum}}
  g_padding="${g_padding}${PADSTR}"
}

# Run a command and display the command in debug
f_debugrun()
{
  local l_level="$1"
  shift
  local l_comm="$@"

  f_debug "${l_level}" "${l_comm}"
  eval "${l_comm}"
}

# Run a command and display the command in debug in stderr
f_debugrunstderr()
{
  local l_level="$1"
  shift
  local l_comm="$@"

  f_debug "${l_level}" "${l_comm}" >&2
  eval "${l_comm}"
}

# Display a green message
f_ok()
{
  echo -e "${TC_GRE}NOTE: ${g_padding}$@${TC_STD}"
}

# Display a red message
f_ko()
{
  echo -e "${TC_RED}NOTE: ${g_padding}$@${TC_STD}"
}

# -----------------------------------------------------------------------------
#  Init: usage and argument parsing
# -----------------------------------------------------------------------------

# Display the script's usage
f_usage()
{
  echo -e "\
${TC_BOLD}NAME${TC_STD}
    ${SCRIPT_NAME} - Script used to check signature and fls files

${TC_BOLD}SYNOPSIS${TC_STD}
    ${SCRIPT_NAME} [OPTIONS] signature|fls ...

${TC_BOLD}DESCRIPTION${TC_STD}
    Signature checker script used to verify signature of both the signature
    file and FLS files, using configuration from a configuration file.

    To verify the signature file : The signature file is checked against a PKI,
    a public key infrastructure, which is created from data retrieved from the
    configuration file.

    To verify any FLS file : The FLS file is checked against a SIF file, which
    has to be previously verified. Again, the data used to find the SIF file
    is described in the configuration file.

${TC_BOLD}OPTIONS${TC_STD}
    ${TC_BOLD}Script options${TC_STD}
    --help|-h                 : Print help
    --debug LEVEL             : Set debug level to LEVEL
    -v|--verbose              : Verbose mode
    -c|--config CONF          : Force the path to the configuration file
                                (defaults to ${G_DEFAULT_CONF_PATH})
    -l|--listening-path PATH  : Set PATH as the path to listen for file to check
    -f|--fifo FIFO            : Send status to FIFO list
    signature                 : Set target to be a signature file
                                This will compare it to PKI information
    file                      : Set target to be a regular file
                                This will compare it to previously verified
                                signature files

${TC_BOLD}EXAMPLE${TC_STD}

    ${TC_BOLD}To start the verification of a SIF file${TC_STD}
    ${SCRIPT_NAME} signature -l /var/dataloading/signaturefiles/

    ${TC_BOLD}To start the verification of an FLS file${TC_STD}
    ${SCRIPT_NAME} file -l /var/dataloading/dlagent/upload/

  "
}

f_checkinput()
{
  if [ -z "${G_ToCheckFile}" ]; then
    f_fatal "Missing --file option"
    f_projectFailSigCheck
    exit 1
  fi
}

f_argsParse()
{
  local l_var

  # ---------------------------------------------------------------------------
  #   Parse arguments
  #
  while [ $# -gt 0 ]; do
    case $1 in
      --help|-h)
        f_usage
        exit 0
        ;;
      -v|--verbose)
        G_verbose=true
        shift
        ;;
      -c|--config)
        # Change the configuration path to the new arg
        G_configPath="$2"
        shift 2
        ;;
      -f|--file)
        G_ToCheckFile="$2"
        shift 2
        ;;
      -p|--fifo)
        if [ -z "${G_fifo}" ]; then
          G_fifo="$2"
        else
          G_fifo="${G_fifo} $2"
        fi
        shift 2
        ;;
      -*)
        f_fatal "Invalid option $1"
        f_projectFailSigCheck
        exit 1
        ;;
      signature)
        f_notice "Verifying signature file"
        G_target="signature"
        shift
        ;;
      file)
        f_notice "Verifying file"
        G_target="file"
        shift
        ;;
      *)
        f_fatal "Invalid option $1"
        f_projectFailSigCheck
        exit 1
        ;;
    esac
  done

  # Input check
  f_checkinput

  # Readonly to all later-on initialized variables
  for l_var in $( set -o posix ; set | cut -d= -f 1 | grep "^G_.*"); do
    eval "readonly ${l_var}"
  done
}

# -----------------------------------------------------------------------------
#  Core functions
# -----------------------------------------------------------------------------

f_build_cert_list()
{
  local l_certFolder="${CONF_PKI_FOLDER}"
  local l_certExtensions="${CONF_PKI_FILE_EXTENSION}"
  local l_output=""

  local l_certext
  local l_file

  for l_certext in ${l_certExtensions}; do
    for l_file in $(find "${l_certFolder}" -name "*${l_certext}" -type f); do
      l_output="${l_output} -c ${l_file} "
    done
  done
  echo -n -e "${l_output}"
}

f_build_pkiparam_file()
{
  local l_pkiparam="${CONF_PKIPARAM_PATH}"
  local l_output="  "

  if [ -e "${l_pkiparam}" ]; then
    l_output=" -p ${l_pkiparam} "
  fi
  echo -n -e "${l_output}"
}

f_build_signaturefiles()
{
  local l_PN="$1"
  local l_sifExtensions="${CONF_SIG_FILE_EXTENSION}"
  local l_output=""
  local l_count=0

  local l_sifFolder="$(echo "${CONF_SIG_FOLDER}" | sed "s/${CONF_PN_PATTERN}/${l_PN}/g")"

  local l_sifext
  local l_file

  for l_sifext in ${l_sifExtensions}; do
    for l_file in $(find "${l_sifFolder}" -name "${l_PN}*${l_sifext}" -type f); do
      l_output="${l_output} -s ${l_file} "
      l_count=$((${l_count} + 1))
    done
  done

#  if [ ! -z "${CONF_NB_EXPECTED_SIF}" ] && [ ${l_count} -le ${CONF_NB_EXPECTED_SIF} ]; then
#    f_error "Incorrect number of SIF found in folder '${l_sifFolder}'. Expected less of equal than '${CONF_NB_EXPECTED_SIF}', but found '${l_count}'"
#    exit 1
#  fi

  echo -n -e "${l_output}"
}

f_signatureCheck()
{
  local l_target="$1"

  local l_certs="$2"

  local l_pkiparam="$3"

  local l_signaturefiles="$4"

  local l_tocheckfile="$5"

  local l_addVerb=""

  if [ "${G_verbose}" = "true" ]; then
      l_addVerb="-v"
  fi

  f_ifverb "signaturechecker ${l_target} ${l_addVerb} ${l_certs} ${l_pkiparam} ${l_signaturefiles} ${l_tocheckfile}"

  signaturechecker ${l_target} ${l_addVerb} ${l_certs} ${l_pkiparam} ${l_signaturefiles} ${l_tocheckfile}
}

f_movefile()
{
  local l_filename="$1"
  local l_PN="$2"
  local l_conf
  local l_tmpfullpath

  # Use by default the CONF_DEFAULT_DESTINATION
  local l_destinations="${CONF_DEFAULT_DESTINATION}"

  # If the current file is found in the CONF_DESTINATION patern list, update the destination to choose the item in the list instead
  for l_conf in ${!CONF_DESTINATION[*]}; do
    if [ ! -z "$( echo "$(basename ${l_filename})" | grep -E "${l_conf}")" ]; then
      l_destinations="${CONF_DESTINATION[${l_conf}]}"
      break
    fi
  done

  # Replace matchword in destination path with the real PN
  l_destinations="$(echo "${l_destinations}" | sed "s/${CONF_PN_PATTERN}/${l_PN}/g")"

  # For every destination on the list, copy the file to a temporary folder, then atomicaly move it
  for l_dest in ${l_destinations}; do
    l_tmpfullpath="${CONF_TEMP_FOLDER}/${l_dest}/$(basename "${l_filename}")"
    mkdir -p "$(dirname "${l_tmpfullpath}")"
    cp "${l_filename}" "${l_tmpfullpath}"

    # Once cp has finished, move to true destination
    mkdir -p "${l_dest}"
    f_notice "Moving file ${l_tmpfullpath} to ${l_dest}"
    mv "${l_tmpfullpath}" "${l_dest}"
    chmod g+rw -R "${l_dest}"
  done

  # Cleanup the files
  rm ${l_filename}
  rm -rf "${CONF_TEMP_FOLDER}/*"
}

f_sendStatusFIFO()
{
  # If at least one FIFO has been set, send status to it
  local l_status="$1"
  local l_fifo

  if [ -z "${G_fifo}" ]; then
    return
  fi

  for l_fifo in ${G_fifo}; do
    echo -ne "${l_status}" > ${l_fifo}
  done
}

source ${SCRIPT_DIRECTORY}/signaturechecker_prj.sh

f_main()
{
  # Build the argument list needed by signaturechecker and feed it to the executable
  # Depending on the output of signaturechecker, move file if successful
  local l_target="${G_target}"
  local l_signaturefiles=""
  local l_certs=""
  local l_pkiparam=""

  local l_findpatern=""
  local l_tocheckfile="${G_ToCheckFile}"

  # The file is always stored in a folder whose name is the PN of the load
  local l_PN="$(basename $(dirname ${l_tocheckfile}))"
  local l_status="${SC_FILE_KO}"

  f_notice "Processing ${l_tocheckfile} with PN ${l_PN}"

#  f_sendStatusFIFO "0"

  case "${l_target}" in
    "file")
        f_notice "Target is file"
        # If processing a file, just retreive the signature file information
        l_signaturefiles="$(f_build_signaturefiles ${l_PN})"
        # XXX For now, the lib needs to have PKI information to let the SIF be parsed
        l_certs="$(f_build_cert_list)"
        l_pkiparam="$(f_build_pkiparam_file)"
        ;;
    "signature")
        f_notice "Target is signature"
        # If processing a signature file, retreive PKI informations
        l_certs="$(f_build_cert_list)"
        l_pkiparam="$(f_build_pkiparam_file)"
        ;;
    *)
        f_fatal "Incorrect target '${l_target}'."
        f_projectFailSigCheck
        exit 1
  esac


  f_signatureCheck "${l_target}" "${l_certs}" "${l_pkiparam}" "${l_signaturefiles}" "${l_tocheckfile}"

  # $? contains the result of the signaturechecker opperation (0 is successfull)
  if [ "$?" = "0" ]; then
    f_notice "File '${l_tocheckfile}' cleared the signature check. Now verifying based on project specific need"

    f_projectCheck "${l_target}" "${l_certs}" "${l_pkiparam}" "${l_signaturefiles}" "${l_tocheckfile}"

    if [ "$?" = "0" ]; then
        f_notice "Check of file '${l_tocheckfile}' successfull."
        l_status="${SC_FILE_OK}"
    else
        f_error "FILE '${l_tocheckfile}' COULD NOT PASS PROJECT SPECIFIC NEEDS"
        logger "FLSSIGCHCKF"
    fi
  else
      f_error "FILE '${l_tocheckfile}' COULD NOT BE VERIFIED"
      logger "FLSSIGCHCKF"
  fi

  # Stub mode => Always accept
#  if [ "${l_status}" != "${SC_FILE_OK}" ]; then
#      f_warn  "| -- Stub mode => SUCCESS"
#      l_status="${SC_FILE_OK}"
#  fi

  # Signature ok => Move file
  if [ "${l_status}" = "${SC_FILE_OK}" ]; then
      f_movefile "${l_tocheckfile}" "${l_PN}"
  fi

  # Send status
  f_sendStatusFIFO "${l_status}"

  f_projectEndFunction "${l_status}"
}

# =============================================================================
#  MAIN
# =============================================================================
# Note   : This section contains the script's main call.
# =============================================================================

# Initiate the arguments parsing
f_argsParse "$@"

## Parse configuration
source "${G_configPath}"

# Main here
f_main

